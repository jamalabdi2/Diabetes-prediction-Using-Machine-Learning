# -*- coding: utf-8 -*-
"""Diabetes_Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ByksQXFUHg3i7XSkRgvoVxXjgp1j3XPT

**DIABETES PREDICTION**

**IMPORTING REQUIRED LIBRARIES**
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os

from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler,LabelEncoder
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report
from imblearn.combine import SMOTETomek

import tensorflow as tf
import warnings
warnings.filterwarnings('ignore')
import pickle
import joblib
sns.set()

"""**Reading Data**"""

DIABETES_DATASET_PATH = '/content/diabetes (1).csv'

def load_diabetes_dataset(path: str):
    '''
    This function loads the diabetes dataset from a CSV file and returns a pandas DataFrame.

    Parameters:
    ----------
    path : str
        The path to the diabetes dataset file.

    Returns:
    -------
    pandas.DataFrame
        The diabetes dataset.

    Raises:
    -------
    FileNotFoundError
        If the file does not exist.
    '''

    try:
        diabetes_dataset = pd.read_csv(path)
    except FileNotFoundError:
        raise FileNotFoundError(f'Could not find the diabetes dataset at: {path}')

    return diabetes_dataset

diabetes_dataset = load_diabetes_dataset(DIABETES_DATASET_PATH)
diabetes_dataset.head()

"""**Understanding a diabetes dataset**"""

diabetes_dataset.shape

#dataset data types
diabetes_dataset.dtypes

#names of the columns
diabetes_dataset.columns

#information about the dataset
diabetes_dataset.info()

#statistic about the dataset
diabetes_dataset.describe()

#missing values
diabetes_dataset.isnull().sum()

"""**Data Analysis**"""

diabetes_dataset.dtypes

def visualization(dataframe: pd.DataFrame, plot_kind: str):
  plot_kind= plot_kind.lower()
  plot_types = ['histogram','kdeplot','violinplot','boxplot']

  if plot_kind not in plot_types:
    raise ValueError(f'{plot_kind} is not found in {plot_types}')
  else:
    print(f'You have choosen: {plot_kind}')

  plot_functions = {
      'kdeplot':sns.kdeplot,
      'boxplot':sns.boxplot,
      'violinplot':sns.violinplot,
      'histogram':sns.displot
  }

  fig = plt.figure(figsize = (12,8))
  for index,column in enumerate(dataframe.columns):
    axis = fig.add_subplot(3,3,index+1)
    if plot_kind in ['violinplot','boxplot']:
      plot_functions[plot_kind](y = dataframe[column],ax=axis)
      plt.title(f'{plot_kind} for {column}')
    else:
        plot_functions[plot_kind](dataframe[column],ax=axis)
        plt.title(f'{plot_kind} for {column}')
  plt.tight_layout()
  plt.show()

#boxplot
visualization(diabetes_dataset,'boxplot')

#boxplot
visualization(diabetes_dataset,'violinplot')

visualization(diabetes_dataset,'histogram')

#boxplot
visualization(diabetes_dataset,'kdeplot')

#correlation
correlation = diabetes_dataset.corr()
correlation

plt.figure(figsize=(8,5))
sns.heatmap(correlation,annot = True,cbar=True,fmt='.1g')
plt.show()

sns.pairplot(diabetes_dataset, hue = "Outcome")
plt.show()



#Replace Glucose,BloodPressure,SkinThickness,Insulin ,BMI with median
columns = ['Glucose','BloodPressure','SkinThickness','Insulin','BMI']
for column in columns:
  diabetes_dataset[column].replace(0,diabetes_dataset[column].median(),inplace = True)

diabetes_dataset.describe()

#target column distribution
vc = diabetes_dataset['Outcome'].value_counts()
print(vc)
vc.plot(kind = 'bar')
plt.title('Target column Distribution')
plt.show()
#imbalanced dataset

#train test split
features = diabetes_dataset.drop('Outcome',axis = 1)
target = diabetes_dataset['Outcome']

#upsampling using smote
smote = SMOTETomek(random_state = 42,n_jobs =-1)
features,target = smote.fit_resample(features,target)
print(features.shape,target.shape)

vcounts = target.value_counts()
print(vcounts)
vcounts.plot(kind = 'bar')
#balanced dataset

#split data again into train and test data
train_data,test_data,train_labels,test_labels = train_test_split(features,target,stratify = target,test_size=0.3,random_state=1)

print(features.shape)
print(train_data.shape)
print(train_labels.shape)
print(test_data.shape)
print(test_labels.shape)

#standard scaler
scaler = StandardScaler()
trained_scaled = scaler.fit_transform(train_data)
test_scaled = scaler.transform(test_data)

#base model logistic regression
reg_model = LogisticRegression()
reg_model.fit(trained_scaled,train_labels)
reg_prediction = reg_model.predict(test_scaled)
reg_accuracy = accuracy_score(test_labels,reg_prediction)
print('Accuracy for Regression model: ',round(reg_accuracy,2))

#confusion matrix
reg_confusion = confusion_matrix(test_labels,reg_prediction)
reg_confusion

# heatmap
sns.heatmap(reg_confusion,annot=True,fmt = '.3g')
plt.show()

# other models training
models = [LogisticRegression(),RandomForestClassifier(),KNeighborsClassifier(),SVC(kernel='linear')]

def model_performance(model_list):
  model_results = []
  for model in model_list:
    model.fit(trained_scaled,train_labels)
    prediction = model.predict(test_scaled)
    accuracy = accuracy_score(test_labels,prediction)
    accurate = round(accuracy,2)
    model_results.append({'Model Name':str(model),'Model Accuracy':accurate})
  return pd.DataFrame(model_results)


model_performance(models)

randomforest_model = RandomForestClassifier()
randomforest_model.fit(trained_scaled,train_labels)
rf_prediction = randomforest_model.predict(test_scaled)
rf_accuracy = accuracy_score(test_labels,rf_prediction)
final_accuracy = round(rf_accuracy,2)
print('RF Accuracy: ',final_accuracy)
rf_confusion_matrix = confusion_matrix(test_labels,rf_prediction)
print(rf_confusion_matrix)

sns.heatmap(rf_confusion_matrix,annot=True,fmt = '.3g')

report = classification_report(test_labels,rf_prediction)
print(report)

#save model
with open('diabetes_randomforest_model.pkl','wb') as f:
  pickle.dump(randomforest_model,f)

joblib.dump(randomforest_model,'randomforest_joblib_model.pkl')



# load pickle
#with open('model.pkl', 'rb') as f:
    #clf2 = pickle.load(f)
# load joblib
#clf2 = joblib.load("model.pkl")

ann_model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(84,activation ='relu',input_shape = ([8])),
    tf.keras.layers.Dense(42,activation ='relu'),
    tf.keras.layers.Dense(1,activation = 'sigmoid')
])

ann_model.summary()

ann_model.compile(loss= 'binary_crossentropy',optimizer = 'adam',metrics= ['accuracy'])

mycallback = tf.keras.callbacks.EarlyStopping(monitor='loss',patience = 3)
model_history = ann_model.fit(trained_scaled,train_labels,epochs = 25,callbacks = [mycallback])

ann_df = pd.DataFrame(model_history.history)
ann_df

plt.figure(figsize=(5,5))
ann_df.plot()
plt.title('Accuracy and loss for model')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.show()

#eevaluate the model
loss,accuracy = ann_model.evaluate(test_scaled,test_labels)
print(f'Model Loss: {loss}')
print(f'Model Accuracy: {accuracy}')

prediction = ann_model.predict(test_scaled)

#Outcome: To express the final result 1 is Yes and 0 is No
prediction_label_str = [ 'Diabetic' if value[0]>=0.5 else 'Not Diabetic'for value in prediction]
prediction_label_str
prediction_label_num = [1 if pred[0]>=0.5 else 0 for pred in prediction]
prediction_label_num
actual_label_str = [ 'Diabetic' if value ==1 else 'Not Diabetic'for value in test_labels]
actual_label_str

compare_df = pd.DataFrame({'Actual Prediction':test_labels,'Predicted value':prediction_label_num,'Actual String':actual_label_str,'Predicted String':prediction_label_str})
compare_df.head(30)

ann_confusion_m = confusion_matrix(test_labels,prediction_label_num)
ann_confusion_m